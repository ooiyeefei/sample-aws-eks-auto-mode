# Multi-Tenant Open WebUI Setup

> **ðŸ“‹ Step 3 of 6**: This should be completed after the main Terraform infrastructure deployment.

## Multi-Tenant Architecture

This deployment supports **three isolated tenants** with shared infrastructure for cost optimization:

### **Tenant Overview**
- **HR Tenant**: `hr-webui` namespace - Full features including web search capabilities
- **Legal Tenant**: `legal-webui` namespace - Document-focused deployment
- **US Tenant**: `us-webui` namespace - Document-focused deployment

### **Shared Components** (Deploy Once)
- **EKS Cluster**: Single cluster serving all tenants
- **Apache Tika**: Shared document processing service
- **vLLM**: Shared inference service (optional)
- **Storage Class**: Shared EBS storage class

### **Tenant-Specific Components** (Per Tenant)
- **Namespace**: Isolated Kubernetes namespace
- **S3 Bucket**: Separate bucket per tenant
- **PostgreSQL Database**: Separate database per tenant
- **Load Balancer**: Separate NLB per tenant
- **Secrets**: Tenant-specific credentials

## Prerequisites

Before deploying Open WebUI, ensure you have:
1. âœ… **Completed**: Main Terraform infrastructure deployment ([see main README](../README.md))
2. An EKS Auto Mode cluster running
3. The AWS CLI configured with appropriate credentials
4. kubectl configured to access your cluster
5. **Custom GAR GPT image** available in ECR (pre-built and ready to use)

## Tenant Selection

**Available tenant options:**

| Tenant | Export Command | Namespace | Features |
|--------|---------------|-----------|----------|
| **HR** | `export TENANT=hr` | `hr-webui` | Full features + web search |
| **Legal** | `export TENANT=legal` | `legal-webui` | Document-focused |
| **US** | `export TENANT=us` | `us-webui` | Document-focused |

**Choose your tenant before proceeding:**

```bash
# Option 1: HR Tenant (includes web search capabilities)
export TENANT=hr
export NAMESPACE=hr-webui

# Option 2: Legal Tenant (document-focused)
export TENANT=legal
export NAMESPACE=legal-webui

# Option 3: US Tenant (document-focused)
export TENANT=us
export NAMESPACE=us-webui

# Verify your selection
echo "Selected tenant: $TENANT"
echo "Target namespace: $NAMESPACE"
```

## OAuth Configuration (Optional)

This deployment supports OAuth/SSO authentication with Microsoft Azure AD and other providers.

### OAuth Setup

1. **Configure OAuth environment file**:
   ```bash
   # Copy the OAuth template (from project root)
   cp ../.env-oauth.tpl ../.env-oauth
   ```
   Edit the OAuth credentials file and add your sensitive OAuth credentials:
   ```bash
   MICROSOFT_CLIENT_SECRET=your-microsoft-client-secret-here
   OAUTH_CLIENT_SECRET=your-oauth-client-secret-here
   OPENID_PROVIDER_URL=https://your-openid-provider-url/openid-configuration
   ```

2. **Update OAuth secrets for your tenant**:
   ```bash
   # Run the multi-tenant OAuth secrets update script
   ./update-oauth-secrets.sh $TENANT
   
   # Or run interactively (will prompt for tenant selection)
   ./update-oauth-secrets.sh
   ```
   
   This script will:
   - Read your OAuth credentials from `../.env-oauth`
   - Update the AWS Secrets Manager secret
   - Sync with External Secrets Operator for your selected tenant

## Deployment Steps

### Phase A: Shared Components (Deploy Once)

If you're in the terraform folder:
```bash
cd ../setup-openwebui
```

Deploy shared infrastructure that serves all tenants:

```bash
# Deploy shared storage class
kubectl apply -f shared/sc.yaml

# Deploy shared ClusterSecretStore (External Secrets Operator)
kubectl apply -f shared/cluster-secret-store.yaml

# Deploy Apache Tika for document processing (shared across all tenants)
helm repo add tika https://apache.jfrog.io/artifactory/tika
helm repo update
kubectl apply -f shared/namespace.yaml
helm install tika tika/tika -f shared/tika-values.yaml -n vllm-inference
```

[Optional: vLLM setup]
```bash
# OPTIONAL: Deploy shared vLLM inference service
kubectl create secret generic hf-secret  -n vllm-inference --from-literal=hf_api_token=<hugging-face-token>
kubectl apply -f ../nodepools/gpu-nodepool.yaml
kubectl apply -f shared/llm.yaml
```

### Phase B: Tenant-Specific Deployment

Navigate to your selected tenant directory and deploy tenant-specific resources:

```bash
# Navigate to your tenant directory
cd $TENANT

# Deploy tenant namespace
kubectl apply -f namespace.yaml

# Deploy tenant OAuth configuration
kubectl apply -f oauth-config.yaml

# Deploy secrets and database setup (generated by Terraform)
kubectl apply -f secret.yaml
kubectl apply -f oauth-secret.yaml

# Create the pgvector extension for this tenant's database
kubectl apply -f pgvector-job.yaml
```

```bash
# Check pgvector job status
kubectl get jobs -n $NAMESPACE
kubectl logs job/pgvector-setup -n $NAMESPACE
```

Wait for the pgvector job to complete successfully, then continue:

```bash
# Deploy OpenWebUI for this tenant
helm repo add open-webui https://helm.openwebui.com/
helm repo update
helm upgrade --install open-webui-$TENANT open-webui/open-webui -f values.yaml -n $NAMESPACE

# Deploy tenant-specific load balancer
kubectl apply -f lb.yaml
```

## Configuration Details

### Tenant Isolation

Each tenant operates in complete isolation:

- **Namespace Separation**: Each tenant has its own Kubernetes namespace
- **S3 Storage**: Separate S3 bucket per tenant with Pod Identity access
- **Database Isolation**: Separate PostgreSQL database per tenant
- **Load Balancer**: Dedicated NLB per tenant for external access

### S3 Document Storage

Each tenant has its own S3 bucket for document storage:

```yaml
persistence:
  enabled: true
  provider: "s3"
  s3:
    bucket: "${s3_bucket_name}"  # Tenant-specific bucket
    region: "${region}"
```

**Pod Identity for S3 Access**: Each tenant uses its own IAM role for secure S3 access without AWS credentials.

### PostgreSQL Vector Database

Each tenant has its own database on the shared RDS instance:

```yaml
extraEnvVars:
  - name: "DATABASE_URL"
    valueFrom:
      secretKeyRef:
        name: "openwebui-db-credentials"
        key: "url"
  - name: "VECTOR_DB"
    value: "pgvector"
```

### Shared Services Integration

All tenants share common services for cost optimization:

- **Apache Tika**: `http://tika.vllm-inference.svc.cluster.local:9998`
- **vLLM Service**: `http://vllm-service.vllm-inference.svc.cluster.local/v1`

## Accessing Your Tenant

After deployment, access your tenant's OpenWebUI through its dedicated load balancer:

```bash
# Get your tenant's load balancer URL
export LB_URL=$(kubectl get service open-webui-service -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')

# Display the URL
echo "Open WebUI for $TENANT tenant is available at: http://$LB_URL"
```

The load balancer may take a few minutes to provision. Once ready, access your tenant's OpenWebUI by opening the URL in your browser.

## Verification Steps

### Verify Tenant Isolation

```bash
# Check your tenant's namespace
kubectl get all -n $NAMESPACE

# Verify tenant-specific resources
kubectl get pods -n $NAMESPACE
kubectl get services -n $NAMESPACE
kubectl get secrets -n $NAMESPACE
```

### Verify S3 Document Storage

1. **Upload a document in your tenant's OpenWebUI**
2. **Verify it's stored in the correct S3 bucket**:
   ```bash
   # Get your tenant's S3 bucket name
   cd ../terraform
   terraform output | grep "webui-docs" | grep ${TENANT}
   
   # List objects in your tenant's bucket
   aws s3 ls s3://your-tenant-bucket-name/
   ```

### Verify PostgreSQL Integration

1. **Check database connection**:
   ```bash
   # View your tenant's database secret
   kubectl get secret openwebui-db-credentials -n $NAMESPACE -o yaml
   
   # Check pgvector extension status
   kubectl logs job/pgvector-setup -n $NAMESPACE
   ```

### Verify Shared Services Access

```bash
# Test Tika service connectivity
kubectl run test-tika --rm -i --tty --image=curlimages/curl -- \
  curl -X GET http://tika.vllm-inference.svc.cluster.local:9998/tika

# Check if vLLM is accessible (if deployed)
kubectl run test-vllm --rm -i --tty --image=curlimages/curl -- \
  curl -X GET http://vllm-service.vllm-inference.svc.cluster.local/v1/models
```

## Tenant-Specific Features

### HR Tenant
- Full document processing capabilities
- Additional web search features (configured separately via setup-searxng/)
- Enhanced RAG capabilities with real-time web data

### Legal & US Tenants
- Document-focused deployment
- Optimized for internal knowledge base
- Enhanced document security and processing


## Multi-Tenant Management

### Deploying Additional Tenants

To deploy another tenant, simply repeat Phase B with a different tenant selection:

```bash
# Deploy Legal tenant
export TENANT=legal
export NAMESPACE=legal-webui
cd legal
# Follow Phase B steps...

# Deploy US tenant
export TENANT=us
export NAMESPACE=us-webui
cd us
# Follow Phase B steps...
```

### Updating OAuth for Specific Tenants

```bash
# Update OAuth for a specific tenant
./update-oauth-secrets.sh hr
./update-oauth-secrets.sh legal
./update-oauth-secrets.sh us
```

## Next Steps

ðŸ”„ **Continue to Step 4**: Once your tenant's OpenWebUI is successfully deployed and verified, proceed to set up LiteLLM as a shared multi-provider gateway.

**ðŸ‘‰ Next: [Setup LiteLLM](../setup-litellm/)**

LiteLLM provides shared services for all tenants:
- Multi-provider LLM routing (local vLLM + external APIs)
- Cost tracking and usage monitoring across tenants
- Centralized API key management
- Redis caching for improved performance

**ðŸ‘‰ For HR Tenant: [Setup SearXNG](../setup-searxng/)**

If you deployed the HR tenant, you can optionally set up SearXNG for web search capabilities.
